Title: Writeup for Project 4, Summer 2015

Date: 7/25/2015

Group Num 11: Name
              Vance Lindholm 
              George Li
              Yoshua Lo

I. Requirements:
	
	All agents (passengers, liaison officers, etc.) must be separated into their own independently-functioning
	files that only work together via communication through a set of servers. These agents must be started through
	Exec system calls. Nachos instances must be able to run at least 10 user programs each, concurrently.
	There must also be a set of servers (5+) that cooperate to process client messages and keep the simulation running.
	
II. Assumptions:

	We have 32768 physical pages
	Nachos works accordingly
	We do not need virtual memory
	Clients randomly request servers

III. Design:

	For our agents we pulled each of them out of our original airport simulation that was created in Project 2. We separated
	each object into their own .c files and created a setup.h file in threads that initialized all the locks, cvs, and mvs. The 
	data is stored on the server-side and can be accessed by a client. We assumed that a client will randomly select a server
	to message.
	
	Servers can also communicate with each other. Once a server receives a user request, they will check to see if there are many
	servers or just 1. If there is only one, then they will function as they did in Project3. However, if there are more than one
	server, then they will utilize a requestQueue to communicate with each other. Once a client request comes in, the server will
	check to see if they have the data needed by the client. If they do they will perform the needed task and return to the client.
	However, if the server doesn't have the needed data, then they will see if they have any requests from other servers that 
	match the client request. Based upon that query, the server will either send requests to other servers or try to accomplish the
	task the client is asking for.
	
	For example, if they send out a request and another server responds with a success (that other server completed the needed task), 
	then the server will return to the client with a success. 
	
		serverToServer()
			This function will deal with server to server communication. This includes sending a request to another server and receiving
			a request from another server.
		
		Run()
			We modified the run function in Server to deal with multiple servers. The functionality of run() is very similar to the
			above function that detailed its run.

IV. Implementation:

    + Files Modified
		userprog/addrspace.cc
		userprog/addrspace.h
		userprog/exception.cc
		userprog/progtest.cc
		userprog/syscall.h
		network/server.cc
		test/Airport.c
		threads/synch.cc
		threads/system.cc
		threads/system.h
		machine/machine.cc
		All relevant Makefiles in order for new files to be compiled
			
    + Files added
		test/AirportManager.c
		test/CargoHandler.c
		test/CheckInOfficer.c
		test/NetworkedAirportTest.c
		test/Passenger.c
		test/ScreeningOfficer.c
		test/SecurityOfficer.c
		threads/setup.h
		
    + Data Structures added, and the file they were added to.
		network/server
			struct pendingRequests{
				int doYouHave[5];
				int doYouHaveReply[5];
				int syscall;
				int count;
				int value;
				int clientCount;
				int noOfReplies;
				int flag;
				
				char name[10];
				
				bool received;
				 
				List *requestWaitQueue;
				List *serverQueue;	
				List *clientQueue;
			};
	
    + Data Structures modified, and the file they were added to. 
		threads/system.h
			strct clientPacket{
				bool status;
				int clientID;
			}

    + Functions added and in which file.
		All functions for agents from Airport.c were moved into the now-independent agent files
		NetworkedAirportTest main function
		network/server
			serverToServer
		
    + Functions modified and in which file.
		network/server
			Run()
			Signal()
			Wait()
			Broadcast()
			DestroyCV()
			Destroy()
		
		userprog/exception.cc
			Fork_Syscall() - This was because our fork from project2 was incorrect
			
V. Testing: (For each test case, you must show)
    + How to test

    -Test for Part 1:
		Airport.c (Fixed version of Project 2)
			1. Go to MakeFile in test directory
			2. Uncommend the lines regarding Airport.c/Airport.o
			3. Add the word Airport to the all line (files that are compiled)
			4. gmake test
			5. Run nachos -x ../test/runsim from Userprog
		
		NetworkedAirportTest.c
			1. Run nachos -server 0 -nos 1
			2. Open second window and run nachos -m 1 -x ../test/NetworkedAirportTest
	  
VI. Discussion:
    + Experiment expectation. 
        We expect our tests to all complete successfully and our code to fully accomplish all requirements.
			
    + Experiment result.
    
    + Explanation

VII. Miscellaneous:
	We spend a lot of time getting our Project2 code to work. We realized that our fork syscall was incorrect
	so we had to spend time to fix it up as well as get the rest of our objects to communicate properly. As such,
	we managed to make our project2 code function properly before we started this project. To test this, you can
	use the Airport.c test in the test directory as that code is essentially our Project2 code.
	
	However, for this project, we were not able to fully test and complete the assignment. While we were testing
	part 1, we received many errors that seems to be unresolvable. As such, we didn't manage to fully complete the 
	assignment as needed.