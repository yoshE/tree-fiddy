 Title:  Writeup for Project 1, Summer 2015
 Date:  06/11/15
 Group:	Name	Email	SS#
		George Li			ligeorge@usc.edu			9910019263
		Vance Lindholm		vlindhol@usc.edu			
		Yoshua Lo			yoshualo@usc.edu			3425221391
 
I. Requirements:
1. Implement lock and condition variable functionality.
2. Verify that these structures pass the tests provided.
3. Create an airport simulation which makes use of the lock and condition variable structures to prevent race conditions between its agents.
4. Write tests for the airport simulation to verify that its agents are working as intended.
5. Comment the new and modified code and fill out this writeup document.

II. Assumptions:
1. Airplanes can fit up to 50 passengers each
2. There is only 1 line for Screening Officers
3. There is a line for Security Officers (Returning passengers add themselves to that line)
4. One large method for passenger (Professor says its ok to have 1 large function in passenger. However this means that our test is just one test that runs through each
of the test scenarios.)

III. Design:
The part 1 design was based upon what the professor talked about in class. We used his pseudo code to design the locks and condition variables such that they would
complete the given tests with no worries.

For part 2, we based our code on the professor's pseudo code as well as our own intuition. Using the professor's code as a base, we added on features to allow it to
achieve all the stated requirements. For the passenger, we ensured that it would have an identifier (used to communicate statistics) and would have bags of which it would
give to the Check In Officer. We designed each interaction based upon the requirements for that thread as well as prior interactions. The liaison officer interaction
was coded such because we wanted the passenger to find a line, wait in that line, then talk to the office to move ahead. We used a struct to transfer information between
the the passenger and the liaison officer because that provided the simplest way to transfer data. The passenger would add data to the struct and then wake up the liaison
officer. The officer would then look at that struct and pull all relevant information. This cycle would contain until the officer completed his task and the passenger would
move forward. The liaison officer was based on a while true loop since they never close up shop and will continue to do their job until the simulation is ended. The while loop
ensures that once a passenger leaves, the liaison officer will wake up and look at the size of their line. Depending on that line size, they would either signal the next passenger
or wait for a new passenger to arrive. The other interactions are based upon this one because each interaction is relatively similar. 

For the Screening Officer, we only included 1 line, because we wanted to design it similar to an actual airport. In most real airports, there is only 1 line for screening
and security purposes. Additionally, we wanted the screening officer to loop infinitely while searching for an available security officer because they can't assign a 
passenger to a security officer if that officer is not available.

For the security officer, we decided to make a line for passengers both new and returning because this would streamline the coding process. Instead of only having a line
for returning passengers, we decided that having an overall line so that new passengers would go wait and returning passengers would just join the line. Since the security
officer shouldn't take new passengers before talking to the returning passengers, having a line would prevent that from occuring. The old passenger would join the line and 
if any passenger would slip in, it would be after the old passenger has already been allow to board.

We used a lot of locks and condition variables because we wanted to reduce the risk of running into race conditions. Every time we have critical code, we surrounded that section
with a lock (consistent throughout) to ensure that multiple threads can't access that code at the same time. For example, lining up for the liaison would have a specific lock 
that would control how many people can line up at the same time (1). This means that only one passenger can be reading and incrementing line length at a time. We didn't want to
have a situation where a passenger would read the line length and before they lined up, another passenger would increment that length. Such a race condition would throw our entire
simulation off track.

For the Airport Manager, we have a reference to the Check In Officers, Liaison Officers, Cargo Handlers, and Security Inspectors.  When there are bags on the conveyor and the Airport
Manager walks by, he will check to see if the Cargo Handlers are on break.  If they are on break, the manager will acquire the lock the handlers are waiting on, and will call Broadcast.
The manager constantly checks to see if all passengers for an airline are at the gate and if all baggage for an airline are on the plane.  Once these two conditions are satisfied, the
Airport Manager will acquire the gate lock that the passengers are waiting on and will call a Broadcast.  Once all the planes have taken off, the manager prints the passenger and baggage
information such as number and weight.

IV. Implementation:
	+ Files Modified
	sync.h - lock/CV code
	sync.cc - lock/CV code
	threadtest.h - part 1 tests/part 2 tests/simulation code
	threadtest.cc - part 1 tests/part 2 tests/simulation code
	main.cc - test-running capability code
	
	+ Files added
	No new code files were added.
	
	+ Data Structures added, and the file they were added to.
	1. Lock
	class Lock					-- in files sync.h/sync.cc
	{
		char* name;
		bool available;
		Thread* owner;
		List* waitingThreads;
	}
	2. Condition
	class Condition				-- in files sync.h/sync.cc
	{
		char* name;
		Lock* waitingLock;
		List* waitingCV;
	}
	
	ALL THE BELOW ARE FROM THREADTEST.H
	
	struct Baggage{	
		int airlineCode;		
		int weight;
	};

	struct LiaisonPassengerInfo{
		int baggageCount;
		int airline;
	};

	struct CheckInPassengerInfo{	
		int baggageCount;
		int passenger;
		bool IsEconomy;
		int seat;
		int gate;
		int line;
		std::vector<Baggage> bag;		
	};

	struct ScreenPassengerInfo{		
		int passenger;
		int SecurityOfficer;
	};

	struct SecurityScreenInfo{		
		int ScreenLine;
	};

	struct SecurityPassengerInfo{		
		bool PassedSecurity;
		bool questioning;
		int passenger;
	};
	
	struct Liaison{		
	  char* name;
	  int airline;		
	  int number;		
	  int passengerCount;		
	  int airlineBaggageCount[AIRLINE_COUNT];		
	} info; 
	
	bool SecurityAvailability[SCREEN_COUNT];	
	int liaisonLine[LIAISONLINE_COUNT];		
	int CheckInLine[CHECKIN_COUNT * AIRLINE_COUNT];		
	int SecurityLine[SCREEN_COUNT];		
	int ScreenLine[1];		
	Condition *ScreenLineCV[1];			
	Condition *ScreenOfficerCV[SCREEN_COUNT];		
	Condition *SecurityOfficerCV[SCREEN_COUNT];
	Condition *SecurityLineCV[SCREEN_COUNT];		
	Condition *liaisonLineCV[LIAISONLINE_COUNT];		
	Condition *liaisonOfficerCV[LIAISONLINE_COUNT];		
	Condition *CheckInCV[CHECKIN_COUNT*AIRLINE_COUNT+AIRLINE_COUNT];	
	Condition *CheckInOfficerCV[CHECKIN_COUNT*AIRLINE_COUNT];		
	Condition *CheckInBreakCV[CHECKIN_COUNT*AIRLINE_COUNT];	
	Lock *liaisonLineLock;		
	Lock *liaisonLineLocks[LIAISONLINE_COUNT];	
	Lock *CheckInLocks[CHECKIN_COUNT*AIRLINE_COUNT];	
	Lock *ScreenLocks[SCREEN_COUNT];		
	Lock *SecurityLocks[SCREEN_COUNT];		
	Lock *AirlineBaggage[AIRLINE_COUNT]; 	
	Lock *CheckInLock;		
	Lock *ScreenLines;		
	Lock *CargoHandlerLock;		
	Condition *CargoHandlerCV;		
	bool seats[50*AIRLINE_COUNT]; 
	Lock *airlineSeatLock;	
	Lock *BaggageLock;	
	Lock *SecurityAvail;		
	Lock *SecurityLines;			
	Lock *gateLocks[AIRLINE_COUNT];				
	Condition *gateLocksCV[AIRLINE_COUNT];		
	Lock *LiaisonSeats;			
	std::vector<Baggage> bags;
	std::vector<CargoHandler*> cargoHandlers;
	std::vector<CheckInOfficer*> checkInOfficers;
	std::vector<LiaisonOfficer*> liaisonOfficers;
	std::vector<Baggage> bags;		
	
	THE FOLLOWING ARE ALL FROM THREADTEST.CC
	
	int gates[AIRLINE_COUNT];	
	int LiaisonSeat[AIRLINE_COUNT];
	bool ScreeningResult[PASSENGER_COUNT];
	LiaisonOfficer *liaisonOfficers[LIAISONLINE_COUNT];		
	CheckInOfficer *CheckIn[CHECKIN_COUNT*AIRLINE_COUNT];		
	SecurityOfficer *Security[SCREEN_COUNT];	
	ScreeningOfficer *Screen[SCREEN_COUNT];	
	LiaisonPassengerInfo * LPInfo = new LiaisonPassengerInfo[LIAISONLINE_COUNT];		
	CheckInPassengerInfo * CPInfo = new CheckInPassengerInfo[CHECKIN_COUNT*AIRLINE_COUNT+AIRLINE_COUNT];		
	ScreenPassengerInfo * SPInfo = new ScreenPassengerInfo[SCREEN_COUNT+1];	
	SecurityScreenInfo * SSInfo = new SecurityScreenInfo[SCREEN_COUNT];		
	SecurityPassengerInfo * SecPInfo = new SecurityPassengerInfo[SCREEN_COUNT];		

	deque<Baggage> conveyor;		// Conveyor queue that takes bags from the CheckIn and is removed by Cargo Handlers
	int aircraftBaggageCount[AIRLINE_COUNT];		// Number of baggage on a single airline
	int aircraftBaggageWeight[AIRLINE_COUNT];		// Weight of baggage on a single airline

	int boardingLounges[AIRLINE_COUNT];		// Array of count of people waiting in airport lounge for airline to leave
	int totalPassengersOfAirline[AIRLINE_COUNT];		// Total passengers that should be on an airline
	AirportManager* am = new AirportManager(); //for testing purposes

	int liaisonBaggageCount[AIRLINE_COUNT];			// baggage count from liaison's perspective, per each airline
	std::vector<Passenger *> simPassengers;
	

	+ Functions added and in which file.
	1. void Passenger::Passenger(int n)								-- in files threadtest.h/threadtest.cc
	2. void Passenger::ChooseLiaisonLine()							-- in files threadtest.h/threadtest.cc
	3. void LiaisonOfficer::LiaisonOfficer(int i)					-- in files threadtest.h/threadtest.cc
	4. void LiaisonOfficer::~LiaisonOfficer()						-- in files threadtest.h/threadtest.cc
	5. void LiaisonOfficer::DoWork()								-- in files threadtest.h/threadtest.cc
	6. void CheckInOfficer::CheckInOfficer(int i)					-- in files threadtest.h/threadtest.cc
	7. void CheckInOfficer::~CheckInOfficer()						-- in files threadtest.h/threadtest.cc
	8. void CheckInOfficer::DoWork()								-- in files threadtest.h/threadtest.cc
	9. void CargoHandler::CargoHandler(int n)						-- in files threadtest.h/threadtest.cc
	10. void CargoHandler::~CargoHandler()							-- in files threadtest.h/threadtest.cc
	11. void CardoHandler::DoWork()									-- in files threadtest.h/threadtest.cc
	12. void AirportManager::AiportManager()						-- in files threadtest.h/threadtest.cc
	13. void AirportManager::~AirportManager()						-- in files threadtest.h/threadtest.cc
	14. void AirportManager::EndOfDay()								-- in files threadtest.h/threadtest.cc
	15. void AirportManager::AddCargoHandler(CargoHandler *ch)		-- in files threadtest.h/threadtest.cc
	16. void ScreeningOfficer::ScreeningOfficer(int i)				-- in files threadtest.h/threadtest.cc
	17. void ScreeningOfficer::~ScreeningOfficer()					-- in files threadtest.h/threadtest.cc
	18. void ScreeningOfficer::DoWork()								-- in files threadtest.h/threadtest.cc
	19. void SecurityOfficer::SecurityOfficer(int i)				-- in files threadtest.h/threadtest.cc
	20.	void SecurityOfficer::~SecurityOfficer()					-- in files threadtest.h/threadtest.cc
	21. void SecurityOfficer::DoWork()								-- in files threadtest.h/threadtest.cc
	22. void t1_t1()												-- in files threadtest.h/threadtest.cc
	23. void t1_t2()												-- in files threadtest.h/threadtest.cc
	24. void t1_t3()												-- in files threadtest.h/threadtest.cc
	25. void t2_t1()												-- in files threadtest.h/threadtest.cc
	26. void t2_t2()												-- in files threadtest.h/threadtest.cc
	27. void t3_waiter()											-- in files threadtest.h/threadtest.cc
	28. void t3_signaller()											-- in files threadtest.h/threadtest.cc
	29. void t4_waiter()											-- in files threadtest.h/threadtest.cc
	30. void t4_signaller()											-- in files threadtest.h/threadtest.cc
	31. void t5_t1()												-- in files threadtest.h/threadtest.cc
	32. void t5_t2()												-- in files threadtest.h/threadtest.cc
	33. void TestSuit()												-- in files threadtest.h/threadtest.cc
	34. void AirportTests()											-- in files threadtest.h/threadtest.cc
	35. void testPassenger(int i)									-- in files threadtest.h/threadtest.cc
	36. void testCH(int CHIndex)									-- in files threadtest.h/threadtest.cc
	37. testLiaison(int liaisonIndex)								-- in files threadtest.h/threadtest.cc
	38. testCIO(int i)												-- in files threadtest.h/threadtest.cc
	39. Passenger::~Passenger()										-- in files threadtest.h/threadtest.cc
	40. char Passenger::getName()									-- in files threadtest.h/threadtest.cc
	41. int Passenger::getAirline()									-- in files threadtest.h/threadtest.cc
	42. bool Passenger::getClass()									-- in files threadtest.h/threadtest.cc
	43. int Passenger::getBaggageCount()							-- in files threadtest.h/threadtest.cc
	44. Passenger::getBags()										-- in files threadtest.h/threadtest.cc
	45. int LiaisonOfficer::getPassengerCount()						-- in files threadtest.h/threadtest.cc
	46. int LiaisonOfficer::getPassengerBaggageCount(int n)			-- in files threadtest.h/threadtest.cc
	47. int LiaisonOfficer::getAirlineBaggageCount(int n)			-- in files threadtest.h/threadtest.cc
	48. void CheckInOfficer::setOffBreak()							-- in files threadtest.h/threadtest.cc
	49. bool CheckInOfficer::getOnBreak()							-- in files threadtest.h/threadtest.cc
	50. int CheckInOfficer::getAirline()							-- in files threadtest.h/threadtest.cc
	51. int CheckInOfficer::getNumber()								-- in files threadtest.h/threadtest.cc
	52. char CargoHandler::getName()								-- in files threadtest.h/threadtest.cc
	53. bool CargoHandler::getBreak()								-- in files threadtest.h/threadtest.cc
	54. int CargoHandler::getWeight()								-- in files threadtest.h/threadtest.cc
	55. int CargoHandler::getCount()								-- in files threadtest.h/threadtest.cc
	56. bool ScreeningOfficer::getBusy()							-- in files threadtest.h/threadtest.cc
	57. void ScreeningOfficer::setBusy()							-- in files threadtest.h/threadtest.cc
	
	+ Functions modified and in which file.
	

V. Testing:  (For each test case, you must show)
Since the professor allowed up to use a large singular function within Passenger, we ended up creating a test case that covers all the singular tests. By heading to the bottom
of threadtest.cc, you can modify how many of each thread are created. For example, by modifying the value of the for loop, you can create 10 passengers versus only 5. Once you
have modified the for loops, you can run the overall test by using nachos -T. The outputs that are required for the complete grade will print and you will be able to see whether
each section was successful. 

The output should look like a long set of strings that contain information on what each thread is doing and whom they are interacting with. By following the set of strings, you
can get a good understanding of what our code is doing.

VI. Discussion:
We expect our experiment to fully complete and for each passenger to successfully board the plane. This means that each plane is filled to capacity and no capacity is lost or left
behind because of race condition.

Obviously, this didn't happen, but we got extremely close. Our passengers still manage to successfully reach the boarding area and prepare for airline boarding procedures. All
baggage is successfully placed onto the correct planes, and each officer does their job correctly. No thread is lost through race conditions and while it may have a mishap or two, 
the overarching case is pretty good. There are a few errors where while loops may cause hang or infinite loops (there is no time for the officer to change state so the loop runs
forever) but these are extremely rare.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.